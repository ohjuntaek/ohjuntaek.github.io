---
layout: post
title: HTTP 완벽 가이드
category: network
tag: ["http", "web"]
---

# HTTP 완벽 가이드

## 01. HTTP 개관

- Hypertext Transfer Protocol
- 웹 서버, 클라이언트
- HTTP를 아는 것은 곧 웹을 아는 것이다!

### 1.3 리소스

- 보통 서버의 정적 파일이 생각이 나는데..
- 어떤 종류의 콘텐츠 소스도 리소스가 될 수 있다고 한다

#### 1.3.1 미디어 타입

- MIME 타입(Multipurpose Internet Mail Extensions) : 메세지 엔터티 본문의 콘텐츠를 설명하는 표준화된 이름(ex text/html, image/jpeg)
  - 원래 각기 다른 전자메일 시스템 사이에서 메세지가 오갈 때 겪는 문제점을 해결하기 위해 설계됐단다 ㅇㅋ
  - 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다.
  - 웹 브라우저는 다룰 수 있는 객체인지 MIME 타입을 통해 확인한다
    - HTTP에서 쓰는 타입이란 말이네 결국
  - 예시 : text/html : HTML로 작성된 텍스트 문서, text/plain : plain ASCII 텍스트 문서, image/jpeg, image/gif, application/vnd.ms-powerpoint
  - 주타입(primary object type)/부타입(specific subtype)
  
#### 1.3.2 URI

  - 통합 자원 식별자, 리소스를 고유하게 식별하고 위치를 지정한다.
  - URL과 URN이 있다.

#### 1.3.3 URL

  - 통합 자원 지시자, 특정 서버의 한 리소스에대한 구체적인 위치를 서술
  - 스킴(프로토콜) + 서버의 인터넷 주소 + 웹 서버의 리소스를 가리킴
  - 오늘날 대부분의 URI는 URL이다. 
  
#### 1.3.4 URN

  - 유니폼 리소스 이름
  - 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름
  - 리소스가 그 이름을 변하지 않게 유지하는 한, 리소스를 여기 저기 옮겨도/여러 종류의 네트워크 프로토콜로 접근해도 문제 없다.
  - urn:ietf:rfc:2141과 같은 형식..
  - 아직 널리 채택되지 않았다. 그러니 알아만 두자~
  
### 1.4 트랜잭션

  - 요청 명령과 응답 결과로 구성
  - HTTP 메세지를 이용해 이루어진다.

#### 1.4.1 메서드
  
  - GET, PUT 같은거..
  - 모든 HTTP 요청 메세지는 한 개의 메서드를 갖는다.

#### 1.4.2 상태 코드

- 모든 HTTP 응답 메세지는 상태코드와 함께 반환된다.
- 200 : 성공, 302 : 다시 보내라, 다른 곳에 가서 리소스를 가져가라, 404: 없음. 리소스를 찾을 수 없다.
- 사유 구절(reason phrase)도 같이 보낸다. 200 OK 이런식으로...

#### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다.

- 당연.. 웹페이지는 리소스의 모음

### 1.5 메세지

- 3장에서 자세히
- 3부분으로 이루어짐 : 시작줄, 헤더, 본문 (그림 1-7 참조)

### 1.6 TCP 커넥션

- TCP : Transmission Control Protocol, 전송 제어 프로토콜

#### 1.6.1 TCP/IP

- HTTP가 어디 계층 프로토콜이게?? => 애플리케이션 계층...
- TCP 특징 : 오류없는 데이터 전송, 순서에 맞는 전달, 조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다)
- TCP(전송 계층)와 IP(네트워크 계층)가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합이다.
![그림1-7](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190803_1_HTTP%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%20%EC%8A%A4%ED%83%9D.PNG?raw=true)
- ~~프로토콜 스택에 대해서 알자.. 검색!~~
- 일단 TCP 커넥션이 맺어지면, 클라이언트와 서버간에 메세지가 없어지거나, 손상되거나, 순서가 바뀌는 일은 없다!
- HTTP는 자신의 메세지 데이터를 전송하기 위해 TCP를 사용한다.

#### 1.6.2 접속, IP 주소 그리고 포트번호

- 인터넷 프로토콜(IP) 주소와 포트번호를 사용해 TCP/IP 커넥션을 먼저 맺고 메세지를 전송한다.
- URL로 IP 주소와 포트번호를 알아낼 수 있다.
- IP 주소 대신 도메인 이름/호스트 명이 들어갈 수 있다. DNS로 쉽게 IP로 변환된다.

#### 1.6.3 텔넷을 사용한 실제 예제

- 안된다...
- netcat.. 뭔가 좋은거 같은데 리눅스껀가

### 1.7 프로토콜 버전

### 1.8 웹의 구성요소

- 프락시, 캐시, 게이트웨이, 터널, 에이전트에 대해 설명

#### 1.8.1 프락시

- 웹 보안, 애플리케이션 통합, 성능 최적화에 중요
- 주로 보안을 위해 사용, 6장에서 자세히...

### 1.8.2 캐시

- 특별한 종류의 HTTP 프락시 서버
- 자주 찾는 것의 사본을 저장해 두고 클라이언트가 같은 문서를 요청하면 사본을 받음.. 7장에서 자세히

### 1.8.3 게이트웨이

- 중개자로 동작하는 서버
- 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용
- 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다.
- HTTP/FTP 게이트웨이.. 8장에서 자세히
- CGI!

#### 1.8.4 터널

- 두 커넥션 사이에서 raw 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
- 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송하기 위해 사용
- 예시) 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송해 웹 트래픽만 허용하는 사내 방화벽을 통과 시킴..?? ~~어렵네~~
![그림 1-14 HTTP/SSL 터널](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190803_2_%EB%B9%84HTTP%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%EB%84%88%EB%A8%B8%EB%A1%9C%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC%EC%A0%84%EB%8B%AC%ED%95%98%EB%8A%94%ED%84%B0%EB%84%90(HTTPSSL%ED%84%B0%EB%84%90).PNG?raw=true)
> 보자.. SSL이 오는데 HTTP로 바꾸고?? 내가 보기엔 SSL에 HTTP 담아서 서버로 날리는거 같은데 모르겠다 사실

#### 1.8.5 에이전트

- 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램
- 브라우저는 알겠지만, 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키는 스파이더, 웹로봇 이라는게 있단다. (검색 엔진!) 9장에 자세히..

### 1.10 추가 정보

- RFC 2616 : http://www.ietf.org/rfc/rfc2616.txt HTTP/1.1에 대한 공식 명세
- RFC 1945 : HTTP/1.0
- RFC : Request for Comments
등 아주 좋은 링크가 많다..

## 02. URL과 리소스

- URL이 뭐다? 인터넷의 리소스를 가리키는 표준 이름!

### 2.1 인터넷의 리소스 탐색하기

- 아까 한 거 쭉~나오네
- mailto:, ftp://, rtsp://(스트리밍을 제공하기 위한 프로토콜?)

### 2.2 URL 문법

- 다른 URL 스킴(프로토콜)을 사용하는 것이 전혀 다른 문법을 사용하는 것이 아니다.
- 대부분의 URL 스킴 : 
`<스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>`
- 파라미터 빼고는 다 쉬운거.. 빠르게 가자

#### 2.2.1~9 스킴, 사용자이름, .... 프래그먼트

- 스킴은 대소문자 구별 안한다
- 파라미터: 프로토콜 파라미터, 예시) FTP가 바이너리와 텍스트 포맷 둘 다 지원하는데 바이너리로 보내기 원한다면 ;type=d 뭐 이렇게 할 수 있게 한다..
  - 이름=값 쌍으로 되어 있다

### 2.3 단축 URL

- 상대 URL, 단축 URL, URL 확장... ?? 뭐야 이게

#### 2.3.1 상대 URL

- 지금까지 본건 절대 URL
- 상대 경로..
- **기저 URL** : 상대 URL의 기준이 됨. 가져오는 방법
  - 리소스에서 명시적으로 제공 : html은 <base> 태그를 기술할 수 있단다
  - 리소스를 포함하고 있는 기저 URL : 상대 URL에 기저 URL이 명시되지 않은 리소스에 포함된 경우, 해당 리소스의 URL을 기저 URL로 쓸 수 있다.
  - ~~걍 원리원칙 설명한다고 말을 어렵게 해놨네.. 걍 상대 경로인데 이런 알고리즘을 쓴다 그림 2-5같은..~~
    
![그림2-5 상대URL을 절대URL로 변환하기](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190803_4_%EC%83%81%EB%8C%80URL%EC%9D%84%EC%A0%88%EB%8C%80URL%EB%A1%9C%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0.PNG?raw=true)
> 가끔 웹 코딩하다보면 이거는 왜 먹히고 이거는 왜 안먹히지 이럴때가 있다. 이 때 이 표와 기저 URL이 뭔지 생각하며 차근차근 따라가보자..

#### 2.3.2 URL 확장

- 호스트명 확장(yahoo -> www.yahoo.com으로..), 히스토리 확장

### 2.4 안전하지 않은 문자

#### 2.4.1 URL 문자 집합

- US-ASCII2(안전) + 유럽언어 등 수백가지 언어 + 특정 이진 데이터.. 를 쓸 수 있는 URL을 위해
- 이스케이프 문자열이 설계되었다.

#### 2.4.2 인코딩 체계

- 이스케이프 문자는 %+숫자2개로 이루어진다.. 빈문자는 %20, %는 %25 등..

#### 2.4.3 문자 제한

![표 2-3 제한문자](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190803_3_%EC%84%A0%EC%A0%90%EB%90%98%EC%97%88%EA%B1%B0%EB%82%98%EC%82%AC%EC%9A%A9%EC%9D%B4%EC%A0%9C%ED%95%9C%EB%90%9C%EB%AC%B8%EC%9E%90%EB%93%A4.PNG?raw=true)

#### 2.4.4 좀 더 알아보기

- 알고보면 /~joe 이런게 되는 곳도 있다. 그렇게 만들지 마라..

### 2.5 스킴의 바다

- http, https, mailto, ftp, rtsp/rtspu, file(주어진 호스트 기기에 바로 접근할 수 있는 파일, 호스트가 생략되있으면 로컬호스트가 기본값), news, telnet

### 2.6 미래

- URN, PURL

## 03. HTTP 메세지

### 3.1 메세지의 흐름

- 메세지 : HTTP 앱 간에 주고 받은 데이터 블록
- 인바운드/아웃바운드(트랜잭션 방향 표현), 업스트림, 다운스트림...이 뭔지 알자
- 인바운드 : C -> S, 서버 방향으로 // 아웃바운드 : S -> C, 사용자 에이전트 방향으로
- HTTP 메세지는 요청이건 응답이건 다운스트림으로 흐른다. <=> 메세지의 발송자는 수신자의 업스트림이다. (책 그림 3-2 참조)

### 3.2 메세지의 각 부분

- 메세지 : HTTP에서 사용하는 시작줄, 헤더블록, 본문 으로 이루어진 구조화 된 데이터 블록
- 각 줄은 CRLF단위(캐리지 리턴+개행문자)로 분리된다. 이 줄바꿈 문자열(\r(ASCII 13, CR), \n(ASCII 10, LF))

#### 3.2.1 메세지 문법

```
요청
<메서드> <요청 URL> <버전>
<헤더>

<(엔터티) 본문>

응답
<버전> <상태 코드> <사유 구절>
<헤더>

<(엔터티) 본문>

```

- 메서드

|HTTP 메서드 | 설명 |
|---|---|
| GET | 서버에 어떤 문서를 가져온다 |
| HEAD | 서버에서 어떤 문서에 대해 헤더만 가져온다. |
| POST | 서버가 처리해야 할 데이터를 보낸다. |
| PUT | 서버에 요청 메세지의 본문을 저장한다. |
| TRACE | 메세지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다 |
| DELETE | 지정한 리소스를 서버에서 삭제한다. |

- 상태 코드 : 100대는 정보, 200대는 성공, 300대는 리다이렉션, 400대는 클라이언트 에러, 500대는 서버 에러...(200, 401, 404는 알자)
- 버전 번호 : 1.1이면 1.1까지 커버한다, 2.22가 2.3보다 크다.. 왜냐하면 소수(분수)로 다루어지지 않고 그냥 정수.정수 이기 때문.. 
- 헤더 : 여러줄로 나눌려면 추가 줄 앞에 최소 하나의 공백(스페이스, 탭)이 있어야 한다.. 예시는 뒤에서 자세히

### 3.3 메서드

#### 3.3.1 안전한 메서드 : GET, HEAD

- 서버에 어떤 작용이 없다 -> 서버에서 일어나는 일이 없다.
- HTTP/1.1 준수를 위해선 이 두개는 구현되어야 한다.
> trace 하니깐 어떤 명령어가 있는지 궁금해짐.. 윈도우 cmd는 tracert, 리눅스는 traceroute란다. 윈도우는 잘되네 git bash는 안되고

### 3.4 상태 코드

#### 3.4.1 100-199: 정보성 상태 코드

- 100 CONTINUE
  - 클라이언트가 엔터티 보내기 전에 서버가 받을지 확인하기 위해 사용하는 상태 코드..
  - 주의점이 많다. 67p~69p에 클라이언트/서버/프락시 기준으로 잘 설명 되어있다 혹시 쓸 일 있으면 읽어 볼 것
  - 클라이언트가 100-continue Expect 요청 헤더를 보내야 한다는 걸 알자 
- 101 Switching Protocols

#### 3.4.2 200-299: 성공 상태 코드

- 200 OK, **201 Created(서버 개체를 생성하라는 요청을 위한 것)**, **202 Accepted(요청은 받아들여 졌으나 서버는 어떤 동작도 수행하지 않았다)**, 203 Non-Authoritative Infomation, 204 No Content, 205 Reset Content, 206 Partial Content (표 3-7)

#### 3.4.3 300-399: 리다이렉션 상태 코드

- 뭐 리소스가 옮겨졌으면 글로 가라는 리다이렉션 상태코드와 Location 헤더(선택적)를 보내서 브라우저가 알아서 리다이렉션하게 해주는 상태 코드
- 300 Multiple Choices, **301 Moved Permanently**, 302 Found, 303 See Other, 304 Not Modified, 305 Use Proxy, **307 Temporary Redirect(표 3-8)**
- 302, 303, 307이 비슷하다.. 말도 어렵다. 여튼 302는 1.0, 303은 1.1이여서 혼란때문에 1.1에서 307 쓰라고 권장한단다

#### 3.4.4 400~499: 클라이언트 상태 코드

- **400 Bad Request**, **401 Unauthorized**, **403 Forbidden**, 404 Not Found, 405 Method Not Allowed, 406 Not Acceptable, 407 Proxy Authentication Required, 408 Request Timeout, 409 Conflict, 410 Gone, 411 Length Required, 412 Precondition Failed... 아오 417 Expectation Fail 뭐이래 많어 ( 표 3-9)

#### 3.4.5 500~599 : 서버 에러 상태 코드

- 500 Internal Server Error, 501 Not Implemented, 502 Bad Gateway, 503 Service Unavailable, 504 Gateway Timeout, 505 HTTP Version Not Supported

### 3.5 헤더

- 헤더는 크게 5가지, 일반/요청/응답/엔터티/확장 헤더로 분류된다.

#### 3.5.1 일반 헤더

- 요청/응답 등 어떠한 유형의 메세지에 대한 기본적인 정보를 제공
- ex) Connection, Date, MIME-Version, Trailer chunked transfer, Transfer-Encoding, Upgrade, Via(표3-11)
- 일반 캐시 헤더 : Cache-Control, Pragma

#### 3.5.2 요청 헤더

- Client-IP, From(메일 주소란다), Host, Referer, UA-Color, UA-CPU, UA-Disp, UA_OS, UA-Pixels, User-Agent
- Accept 관련 헤더 : 서버에게 서버가 보내도 되는 걸 말해줌
  - Accept, Accept-Charset, Accept-Encoding, Accept-Language, TE(확장 전송 코딩)
- 조건부 요청 헤더 : 아까 한(3.4.1 100 CONTINUE) Expect 같은거.. 제약을 넣는다.
  - Expect, If-Match, If-Modifed-Since, If-None-Match, If-Range, If-Unmodified-Since, Range
- 요청 보안 헤더 : 14장에 자세히
  - Authorization, Cookie(토큰 전달시 사용), Cookie2(요청자가 지원하는 쿠키 버전, 11장)
- 프락시 요청 헤더 : 프락시 기능 돕는다. 6장에서 자세히, Max-Forwards(TRACE와 함께 사용), Proxy-Authorization, Proxy-Connection

#### 3.5.3 응답 헤더

- Age, Public, Retry-After, Server, Title, Warning
- 협상 헤더 : 프랑스어/독일어, 뭐쓸거냐? 협상할 수 있게 하는 헤더.. Accept-Ranges, Vary
- 응답 보안 헤더 : Proxy-Authenticate, Set-Cookie, Set-Cookie2, WWW-Authenticate

#### 3.5.4 엔터티 헤더

- Allow, Location
- 콘텐츠 헤더 : Content-Base...
- 엔터티 캐싱 헤더 : ETag, Expires, Last-Modified

## 04. 커넥션 관리

### 4.1 TCP 커넥션

#### 4.1.2 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

- TCP 커넥션을 통해 TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고 세그먼트를 IP 패킷에 담아 데이터를 전달한다.~~이건 어디구현되있을까?~~
- IP 패킷 : IP 패킷 헤더, TCP 세그먼트 헤더, TCP 데이터 조각 을 포함한다.

![그림4-4 IP 패킷](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190803_5_%EA%B7%B8%EB%A6%BC4-4_IP%ED%8C%A8%ED%82%B7TCP%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8.PNG?raw=true)
> 참고자료.. 궁금하면 봐라 핵심은 IP 패킷(헤더), TCP 세그먼트(헤더), TCP 데이터 스트림 덩어리로 이루어져있다는 것! 
- 이 패킷 보는거 이름이 뭐였지???? 아 와이어샤크...



#### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 TCP 커넥션을 항상 여러개 가지고 있다. TCP는 포트번호를 통해 이런 여러개의 커넥션을 유지한다.
- 포트번호는 회사 직원의 내선전화랑 비슷한 거란다.
- TCP 커넥션은 (발신지 IP 주소, 발신지 포트, 수신지 IP주소, 수신지 포트) 로 식별한단다 쉽지?

#### 4.1.4 TCP 소켓 프로그래밍

- bind, connect, listen, accept, read, write 기억나니
- 그림 4-6에 어떻게 소켓으로 통신하는지 잘 나와있음. 기억안나면 검색 ㄱ

### 4.2 TCP의 성능에 대한 고려

- TCP는 복잡한 주제이므로 한 번 읽고 넘어간다... 나중에 꼭 하기

### 4.3 HTTP 커넥션 관리

#### 4.3.1 흔히 잘못 이해하는 Connection 헤더

- HTTP 커넥션 헤더가 뭐야... 메세지에서 본 Connection 헤더를 말하는 거 같네
- 여튼 커넥션 헤더에는 세가지 종류의 토큰이 전달될 수 있다
  - HTTP 헤더 필드명은 이 커넥션에만 해당되는 헤더들을 나열한다.
  - 임시적인 토큰 값은, 커넥션에 대한 비표준 옵션을 의미한다.
  - close 값은, 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.
- Connection: meter, close, bill-my-credit-card => Meter 헤더를 다른 커넥션으로 전달하면 안되고, bill-my-credit-card 옵션을 적용할 것이며 이 트랜잭션이 끝나면 커넥션이 끊길 것이라고 말한다.
- 여튼 커넥션 헤더 필드는 메세지를 다른 곳으로 전달하는 시점에 삭제되어야 한단다... 부록 C에 자세히 있단다.

#### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 하나의 리소스를 받을 때 마다 커넥션을 새로 해야만 한다면 느린 시작 지연이 발생한단다... 느린 시작 지연? 걍 느리다는 거 같은데
- 여튼 그래서 동시에 여러 리소스를 받는게 좋은데, 이를 위한 기술로 4가지를 알아보자 : 병렬, 지속, 파이프라인, 다중

### 4.4 병렬 커넥션

- HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.(병렬 커넥션은 여러 개의 서버와 맺어질 수 있어야 한다.. 컴포넌트(리소스)들이 여기저기서 올 수 있기 때문에 당연)

#### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다

- 뭔가 2학년 때 배운 파이프라이닝이랑 비슷한 개념이네.. 그림 4-12 참조

#### 4.4.2 병렬 커넥션이 항상 더 빠르지는 않다.

- 클라이언트의 네트워크 대역폭이 좁을 때(저성능 모뎀 쓰거나..)는 더 느리단다. 병렬 장점이 안 쓰는 대역폭을 활용하여 커넥션을 거의 동시에 생성하는 거니깐 당연하지? 근데 대역폭의 개념을 좀 더 알아야 할듯..
- 또한 다수의 대역폭은 메모리를 많이 소모한단다.

#### 4.4.3 병렬 커넥션은 더 빠르게 느껴질 수 있다. 체감상 그렇단다.

![느린시작커넥션](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190803_6_%EB%8A%90%EB%A6%B0%EC%8B%9C%EC%9E%91%EC%BB%A4%EB%84%A5%EC%85%98.PNG?raw=true)
![병렬커넥션](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190804_7_%EB%B3%91%EB%A0%AC%EC%BB%A4%EB%84%A5%EC%85%98.PNG?raw=true)

### 4.5 지속 커넥션

- 사이트 지역성 : 이미지 등의 리소스가 같은 사이트에 있는 것?(캐시 지역성? 비슷한건가 이게뭐였지근데)
- HTTP/1.1 지원하면 처리가 완료된 후에도 TCP 커넥션을 유지해 앞으로 있을 HTTP 요청에 재사용하는데, 이런걸 지속 커넥션이라 한단다.

#### 4.5.1 지속 커넥션

- 병렬 커넥션의 단점.. ~~을 왜 여기서하냐 여튼~~
  - 각 커넥션을 새로 맺고 끊어서 시간,대역폭 소요됨, 느린 시작, 실제로 연결할 수 있는 병렬 커넥션은 제한이 있음
- 튜닝된 커넥션 : TCP 느린 시작에서 패킷을 수차례 성공적으로 전송한 결과 한번에 다수의 패킷을 전송할 수 있는 권한을 얻은 상태의 커넥션!
- 지속 커넥션의 장점 : 이 튜닝된 커넥션을 유지할 수 있따. 커넥션 수 줄여준다.. 뭐 다 직관적인 거
- 단점 : 당연히 리소스 차지하고 당연하지? 뭔지만 알면 안다
- 그러니깐 같이 짬뽕하는게 좋단다.
- 자... 뭔가 새로운 Keep-Alive 라는게 나오네. 이게 HTTP/1.0에서 쓰던거란다

#### 4.5.2 HTTP/1.0+의 Keep-Alive 커넥션

- 이게 지속 커넥션 아냐? 뭐가다를까.. 그림 4-13보면 상상하던게 나옴

#### 4.5.3 Keep-Alive 동작

- HTTP/1.1에선 사라졌지만, 아직 쓰는데 많으니깐 알아야한다.
- Connection: Keep-Alive 딱 해주면 킵어라이브 해야한다. 응답에도 있어야한다. 없으면 클라이언트에서 커넥션 끊는다..

#### 4.5.4 Keep-Alive 옵션

- Keep-Alive 있다고 커넥션 유지 무조건 할 필요는 당연히 없지 걍 헤더일 뿐이니깐 그걸 명세하는 것 뿐..
- 여튼 그래서 옵션이 있다.. 예시를 보자

```
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
- 뭐겠냐? 딱 봐도 트랜잭션 5개만, 2분동안 커넥션 유지해라는 거 같네..
```

#### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알 수 있어야 커넥션을 유지할 수 있다.
  - 즉, 엔터티 본문이 정확한 Content-Length 값과 멀티파트 미디어 형식(multipart media type)을 가지거나 chuncked transfer encoding으로 인코드 되어야 한다
  - 왜냐.. 트랜잭션이 끝나는 시점에 기존 메세지의 끝과 새로운 메세지의 시작점을 정확히 알 수 없기 때문
  - 그 외 중요한거 많다 이거 쓸 때 꼭 봐라.. p. 107

#### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

- Connection 헤더의 무조건 전달 : p.109 예시 설명 길게 아주 잘 나와있는데.. 한마디로 말해서 커넥션은 한 홉에서만 통신하므로 프락시는 keep-alive가 뭔지 모르는데 클라이언트와 서버는 프락시랑 커넥션이 연결 되있다고 생각해 똑같은 커넥션으로 메세지를 보내지만 무시되어서 타임아웃이 일어나는 현상
- 이를 방지할려면 프락시는 커넥션 헤더와 커넥션 헤더에 명시된 헤더를 절대 전달하면 안된다.(Connection, Keep-Alive)
- 이 내용 좋네.. 프락시 구성할 때 꼭 유념하자

#### 4.5.7 Proxy-Connection 살펴보기

- 서버나 클라이언트는 Proxy-Connection은 무시하기 때문에 멍청한 프락시의 문제를 해결할 수 있음
- 하지만 영리한 프락시 옆에 멍청한 넘 있으면 똑같이 헤더 이상해진다.

![멍청한 프락시](https://github.com/ohjuntaek/ohjuntaek.github.io/blob/master/_posts/resources/190803_8_Keep-Alive%EB%A9%8D%EC%B2%AD%ED%95%9C%ED%94%84%EB%9D%BD%EC%8B%9C.PNG?raw=true)

#### 4.5.8 HTTP/1.1의 지속 커넥션

- 이래서 Keep-Alive를 안쓰는 구만
- HTTP/1.1에서는 별도 설정을 하지 않는한 모든 커넥션을 지속 커넥션으로 취급한다!
- 트랜잭션이 끝난다음 커넥션을 끊으려면 Connection: close를 해야한단다!

#### 4.5.9 지속 커넥션의 제한과 규칙

- 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알수 있어야 커넥션을 유지할 수 있다(아까 Keep-Alive랑 똑같네)
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 대해 별도의 지속 커넥션을 맺고 관리해야 한다(다른 홉에 대해 같은 커넥션을 쓸수가 있나??)
- HTTP/1.1 프락시는 (클라이언트가 커넥션 관련 기능에 대한 클라이언트의 지원 범위를 알고 있지 않은 한? 먼소리야) 지속 커넥션을 맺으면 안된다.
- 하나의 사용자 클라이언트는 두개의 지속 커넥션을 유지해야 서버 과부하가 방지된다.
  - 즉, N명의 사용자가 서버로 접근하면 프락시는 서버나 상위 프락시(?)에 넉넉잡아 2N개의 커넥션을 유지해야 한다.

> 등등 뭐 규칙이 많은데 좀 어렵다. p. 113 잘 보고 프락시 구성할일 있으면 볼 것!

### 4.6 파이프라인 커넥션

- 병렬이랑 약간 관계가 없는 개념인건가? 지속 커넥션을 개선한 느낌인데.. 그림 4-18 보면 알겠지만 트랜잭션을 병렬처리(파이프라이닝?) 한다.
- 여튼 제약 사항이 있다
  - 지속 커넥션인지 확인하고 파이프라인을 이어라
  - 응답은 요청 순서와 같게 와야한다.
  - 서버는 중간에 요청을 끊을 수 있으므로, 언제든 다시 요청을 보낼 준비가 되어있어야 한다.
  - 반복해서 보낼 경우 문제가 생기는 요청은 파이프라인을 통해 보내지마라(POST 같은거..)
  
### 4.7 커넥션 끊기에 대한 미스터리

- 미묘한 커넥션 끊기의 세계, 기술 문서도 별로 없단다..

#### 4.7.1 '마음대로' 커넥션 끊기

> 아까 지속 커넥션 제한 규칙 부터 자꾸 끊는다니까 헷갈리는데.. 아까전에 HTTP는 데이터의 손실이 없다는 걸 보장하고 전송된 순서대로 온다는 걸 보장한다 했잖아? 근데 지속 커넥션에선 맘대로 쳐끊고 말이야.. 커넥션 끊는다고 손실있고 순서가 달라지는 건 아니라 이거지 헷갈리지 말자
> 심지어 전송중에도 

#### 4.7.2 Content-Length와 Truncation

- Truncation은 안 나오는데??
- 지속 커넥션 제약조건에 나온 Content-Length를 알아야 하는 이유.. 를 다시 설명

#### 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 멱등(idempotent) : 말도 어렵다.. 여러 번 실행됐는지에 상관 없이 같은 결과를 반환한다(POST 빼고 다 멱등하다)
- 멱등하지 않은(POST) 요청은 파이프라인을 통해 요청하면 안된다.
  - 왜? 전송 커넥션이 예상치 못하게 끊어지면 알 수 없는 결과를 초래할 수 있단다.. 뭐 글쓰기 같은거 생각해보면 그런거 같네
  - 그렇다고 자동 요청 재시도 하지는 마라 대화상자를 띄우든지 해라

#### 4.7.4 우아한 커넥션 끊기

- 전체 끊기(TCP 입력/출력 둘다 끊기(close()), 절반 끊기(입력/출력 하나만 끊기(shutdown())
- 커넥션의 출력 채널을 끊는 것이 안전하다. 반대편 기기는 요청 받은걸 응답하고 나서 커넥션을 끊었다는 걸 알게 된다.
- 입력 채널을 끊는 것은 위험하다
  - 이미 끊긴 입력 채널에 데이터를 전송하면, 서버가 TCP의 'connection reset by peer' 메세지를 날리고, 서버의 아직 읽히지 않은 데이터를 모두 삭제한다!
- 우아하게 커넥션 끊기
  - 자신의 출력 채널을 먼저 끊고 다른 쪽에 있는 기기의 출력 채널이 끊기는 것을 기다리는 것.

## 12. HTTP/2.0

- 커넥션 하나를 통해 요청 하나를 보내고 응답 하나를 받는 HTTP의 교환 방식(지속 커넥션을 사용해도)이 심각한 회전 지연을 피할 수 없어서 나온 명세
- 구글의 SPDY(스피디)를 기반으로 설계
- 차이점
  - 메세지가 프레임에 담겨 전송되는데, 형식이 좀 다르다(하지만 의미는 같다)
  - 하나의 커넥션에 1.1에서는 하나의 스트림만 열릴 수 있었으나, 2.0에서는 여러개의 스트림을 열 수 있고, 우선 순위 또한 가질 수 있다.
  - 헤더를 압축 시켜 전송한다(1.1 에서는 하지 않았고, 필요하면 deflate 알고리즘을 사용해 압축함)
  - 하나의 요청에 대한 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다(서버 푸시).. 원래 안되나??

## 11. 클라이언트 식별과 쿠키

- 회원가입/로그인에 대한 기초..

## 12. 기본 인증

- HTTP 기본 인증은 ID, 비밀번호를 콜론으로 이어서 합치고 Base-64 인코딩을 사용해 인코딩한다.
- 보안을 위해 SSL을 사용하거나 다이제스트 인증과 같은 프로토콜을 사용한다.

## 13. 다이제스트 인증

- 절대로 비밀번호를 네트워크를 통해 보내지 않는다.
- 잘 쓰지는 않음 보통 SSL 쓰지..

## 14. 보안 HTTP

- 

## 15. 엔터티

## 16. 국제화

## 17. 내용 협상과 트랜스코딩

- 내용 협상 : 클라이언트가 요구하는 콘텐츠에 맞게 전송하기.. (일본어/중국어 중 일본어 전송)
- 트랜스코딩 : 서버가 클라이언트가 요구하는게 없다? 그럼 트랜스코딩해서 보여준다.

## 18. 웹 호스팅

- 호스팅 : 콘텐츠 리소스를 저장, 중개, 관리하는 일... 일반적으로 서버에 콘텐츠 띄우는 거라 생각
- 가상 호스팅 : 한 개의 서버에 여러 개의 사이트를 호스팅 하는 방법(일반적?으로 포트 번호..)

### 18.3 안정적인 웹사이트 만들기

- 서버 팜 : 서로 대신할 수 있고 식별할 수 있게 설정된 웹 서버의 집합.. 뭐야??
- CDN : 콘텐츠 분산 네트워크

## 19. 배포 시스템

- WebDAV? 뭐야이게 

## 20. 리다이렉션과 부하 균형

- 아주 중요한거 같은데

## 21. 로깅과 사용 추적

-------------

# 부록

- URI 스킴, HTTP 상태 코드, HTTP 헤더 레퍼런스, MIME 타입, base-64 인코딩, 다이제스트 인증, 언어 태그, MIME 차셋 등록소






















